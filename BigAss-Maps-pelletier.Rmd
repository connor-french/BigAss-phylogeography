---
title: "BigAss bird phylogeography data exploration"
output: html_notebook
---
Here are some maps exploring our bird data. I have two sets of maps: Maps only with cells where there are at least three individuals per species (>= 3 species tab), and maps that show the species density, rather than observation density (Species density tab). 

First I'm reading in the packages and setting my working directory where the data is, and reading in the data.
```{r, results='hide'}
packages <- c("magrittr", "tidyverse", "sf", "leaflet", "maps", "ggmap", "viridis", "raster", "maptools", "data.table", "stringr")
lapply(packages, require, character.only = TRUE)


#read in data. Had to remove a few bacteria(?) localities from the original csv. investigate later
pelletier.data <- fread("../pelletier-localities.csv")
```


Here I'm extracting the relevant taxon names we want to consider for analysis from the ugly taxonomy hierarchy that genbank returns and assigning them to a column. These are from different taxonomic levels, but represent biologically relevant divisions. I'm also creating a column that assigns the rows as either vertebrate or not for easy separation down the line. Interestingly, there are no marine vertebrate taxa, although the Pelletier and Carsten's study says there were. Will have to investigate this further. There aren't any crocodilians here either!

```{r}
taxa <- pelletier.data$taxonomy #make a vector of genbank's taxonomic hierarchies
interesting.taxa <- "Amphibia|Mammalia|Arthropoda|Aves|Squamata|Testudines|Crocodylia|Crocodilia" #this is my regex expression to extract those taxa we're interested in. the "|" character is an "or" statement. any rows that do not contain one of these taxon assignments will receive an "NA".

pelletier.data$taxa <- str_extract(taxa, interesting.taxa) %>% as.factor()#extracting the taxon names we're interested in and assigning them their own column in the data set

pelletier.data$vertebrate <- str_extract(taxa, "Vertebrata") #creating a column for vertebrates. invertebrates will receive an "NA"

#interestingly, there are no marine mammals in the data set! Will have to investigate this further
#marine.mammals <- "Balaenidae|Cetotheriidae|Balaenopteridae|Eschrichtiidae|Physeteridae|Kogiidae|Monodontidae|Ziphiidae|Delphinidae|Phocoenidae|Sirenia|Pinnipedia"
#pelletier.data$marine.mammals <- str_extract(taxa, marine.mammals)
#pelletier.data$marine.mammals <- as.factor(pelletier.data$marine.mammals)

pelletier.data <- pelletier.data[,!c("taxonomy", "V10")] #removing the taxonomy column (for clarity) and an extra column that got added on when reading the dataset in for some reason


```






I'm removing all localities not in South America and restricting observations to only vertebrates (since there weren't any marine vertebrates in the data set, we don't have to worry about those)

```{r}
#restrict to vertebrates and remove North American/European localities. orig # obs = 697098; filtered # obs = 30,037
pelletier.data$latitude <- as.numeric(pelletier.data$latitude)
pelletier.data$longitude <- as.numeric(pelletier.data$longitude)
pelletier.vert <- subset(pelletier.data, latitude < 12.5) %>%
  subset(latitude > -42) %>%
  subset(longitude < -30) %>%
  subset(longitude > -82)  %>%
  subset(vertebrate == "Vertebrata") %>%
  droplevels.data.frame() 
```

The original number of observations was 697098, and the filtered number of observations is 24267.

Now time for the map! This is of all of our South American localities colored according to country to find outlier/mislabeled points.

```{r}
#convert locality data to a spatial object. The spatial object is basically a shape file that the mapping function can interpret. 

coord_points <- st_as_sf(pelletier.vert, coords = c("longitude", "latitude"), 
                         crs = 4326, agr = "constant")


#load a world map as the base map.
w_map <- map("world", plot = FALSE)

#make color palette
pal <- colorFactor(palette = "inferno", domain = NULL, na.color = "#00000000")

#create popup labels for points
#popup_label <- paste(coord_points$genus, coord_points$Species, "<br>",
#                     coord_points$Country, "<br>",
#                     coord_points$Locality, "<br>",
#                     coord_points$geometry)

#plot in leafly
leaflet(data = w_map) %>% 
  addTiles() %>%
  addCircleMarkers(data = coord_points,
                  #color = ~pal(Country),
                  radius = 5)
```





Now I'm going to apply various filters to the data to look at sampling intensity.

##Sampling Maps {.tabset}


###>=3 per species
Here I'm subsetting the data for only those cells where there are more than 3 observations for a species and then plotting.

100x100 km. 884 species and 19459 observations. Minimum #observations per cell: 3, max: 2175
```{r}
#create a numeric color palette so I can bin the colors (doing this up front so I don't repeatedly assign this variable)
pal2 <- colorNumeric(palette = "inferno", domain = NULL, na.color = "#00000000") 
#Reading in an environmental raster (world clim 2.0 bio1 raster) at 10 arc-minute resolution to use as a raster that utilizes lat-long coordinates for its cells. The raster isn't what's important, what is important is the raster resolution. 
f <- "/Users/connorfrench/Dropbox/Old_Mac/climate-data/wc2.0_10m_bio/wc2.0_bio_10m_01.tif" #raster location

bounds <- extent(-80, -35, -40, 15) #Reduce extent of raster to our area of interest- South America

sa_clim_1d <- raster(f) %>% crop(bounds) %>% aggregate(fact = 6) #read in raster, crop it, and downscale the resolution to 1 degree

#get the cell number of each coordinate pair for filtering. 19459.
pts_ext_1d <- raster::extract(sa_clim_1d, coord_points, fun = "count", sp = TRUE, cellnumbers = TRUE) %>% 
  as.data.frame() %>%
  setnames(old = c("coords.x1", "coords.x2"), new = c("Long", "Lat")) %>% #rename coordinates 
  mutate(cells = as.factor(cells)) %>% #need cells numbers as factors so I can count their frequency
  group_by(species, cells) %>% #group the data set by species, then by cell number
  filter(n() > 2) %>% #retain only observations where there are more than two species observations per cell
  ungroup() %>%
  droplevels()

coordinates(pts_ext_1d) <- ~Long+Lat #convert to a spatial data frame

count_pts_1d <- rasterize(pts_ext_1d, sa_clim_1d, fun = "count", field = "species") #make a raster out of the counts of observations per cell

pal.vert <- colorBin(palette = "inferno", bins = c(0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100,300,500,1000,1500,2000), domain = NULL, pretty = TRUE, na.color = "#00000000")


#plot count map
leaflet(data = sa_clim_1d) %>% 
  addTiles() %>%
  addRasterImage(count_pts_1d, colors = pal.vert,  opacity = 0.8) %>%
  addLegend(pal = pal.vert, values = values(count_pts_1d))
```




200x200 km. 20154 observations, 935 species. Min # observations per cell: 3, max: 3452.
```{r}
sa_clim_2d <- raster(f) %>% crop(bounds) %>% aggregate(fact = 12) #read in raster, crop it, and downscale the resolution to 1 degree

#get the cell number of each coordinate pair for filtering
pts_ext_2d <- raster::extract(sa_clim_2d, coord_points, fun = "count", sp = TRUE, cellnumbers = TRUE) %>% 
  as.data.frame() %>%
  setnames(old = c("coords.x1", "coords.x2"), new = c("Long", "Lat")) %>% #rename coordinates 
  mutate(cells = as.factor(cells)) %>% #need cells numbers as factors so I can count their frequency
  group_by(species, cells) %>% #group the data set by species, then by cell number
  filter(n() > 2) %>% #retain only observations where there are more than two species observations per cell
  ungroup()

coordinates(pts_ext_2d) <- ~Long+Lat #convert to a spatial data frame

count_pts_2d <- rasterize(pts_ext_2d, sa_clim_2d, fun = "count", field = "species") #make a raster out of the counts of observations per cell

pal.vert2d <- pal.vert <- colorBin(palette = "inferno", bins = c(0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100,300,500,1000,1500,2000,3500), domain = NULL, pretty = TRUE, na.color = "#00000000")
#plot count map
leaflet(data = sa_clim_2d) %>% 
  addTiles() %>%
  addRasterImage(count_pts_2d, colors = pal.vert,  opacity = 0.8) %>%
  addLegend(pal = pal.vert, values = values(count_pts_2d))
```


300x300 km. 25459 observations, 1603 species

```{r}
sa_clim_3d <- raster(f) %>% crop(bounds) %>% aggregate(fact = 18) #read in raster, crop it, and downscale the resolution to 1 degree

#get the cell number of each coordinate pair for filtering
pts_ext_3d <- raster::extract(sa_clim_3d, coord_points, fun = "count", sp = TRUE, cellnumbers = TRUE) %>% 
  as.data.frame() %>%
  setnames(old = c("coords.x1", "coords.x2"), new = c("Long", "Lat")) %>% #rename coordinates 
  mutate(cells = as.factor(cells)) %>% #need cells numbers as factors so I can count their frequency
  group_by(species, cells) %>% #group the data set by species, then by cell number
  filter(n() > 2) %>% #retain only observations where there are more than two species observations per cell
  ungroup()

coordinates(pts_ext_3d) <- ~Long+Lat #convert to a spatial data frame

count_pts_3d <- rasterize(pts_ext_3d, sa_clim_3d, fun = "count", field = "species") #make a raster out of the counts of observations per cell

pal.vert3d <- pal.vert <- colorBin(palette = "inferno", bins = c(0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 300, 500, 1000, 1500, 2000, 3000, 5000), domain = NULL, pretty = TRUE, na.color = "#00000000")

#plot count map
leaflet(data = sa_clim_3d) %>% 
  addTiles() %>%
  addRasterImage(count_pts_3d, colors = pal.vert3d,  opacity = 0.8) %>%
  addLegend(pal = pal.vert3d, values = values(count_pts_3d))
```


###Species density
Now I'm going to look at species density per cell for the three resolutions! Just to be clear, this is still using the data set filtered for >= 3 observations per species per cell.

100 km. 
```{r}
pts_ext_1d_sp <- as.data.frame(pts_ext_1d) #convert to data frame for filtering
pts_ext_1d_sp <- pts_ext_1d_sp[!duplicated(pts_ext_1d_sp[c("species", "cells")]),] #filter for unique species in each cell

coordinates(pts_ext_1d_sp) <- ~Long+Lat #convert to a spatial data frame

count_pts_1d_sp <- rasterize(pts_ext_1d_sp, sa_clim_1d, fun = "count", field = "species") #make a raster out of the counts of observations per cell

pal.species <- colorBin(palette = "inferno", bins = c(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100), domain = NULL, pretty = TRUE, na.color = "#00000000")
#plot count map
leaflet(data = sa_clim_1d) %>% 
  addTiles() %>%
  addRasterImage(count_pts_1d_sp, colors = pal.species,  opacity = 0.8) %>%
  addLegend(pal = pal.species, values = values(count_pts_1d_sp))


```

200 km.
```{r}
pts_ext_2d_sp <- as.data.frame(pts_ext_2d) #convert to data frame for filtering
pts_ext_2d_sp <- pts_ext_2d_sp[!duplicated(pts_ext_2d_sp[c("species", "cells")]),] #filter for unique species in each cell

coordinates(pts_ext_2d_sp) <- ~Long+Lat #convert to a spatial data frame

count_pts_2d_sp <- rasterize(pts_ext_2d_sp, sa_clim_2d, fun = "count", field = "species") #make a raster out of the counts of observations per cell


#plot count map
leaflet(data = sa_clim_2d) %>% 
  addTiles() %>%
  addRasterImage(count_pts_2d_sp, colors = pal.species,  opacity = 0.8) %>%
  addLegend(pal = pal.species, values = values(count_pts_2d_sp))
```


300 km.
```{r}
pts_ext_3d_sp <- as.data.frame(pts_ext_3d) #convert to data frame for filtering
pts_ext_3d_sp <- pts_ext_3d_sp[!duplicated(pts_ext_3d_sp[c("species", "cells")]),] #filter for unique species in each cell

coordinates(pts_ext_3d_sp) <- ~Long+Lat #convert to a spatial data frame

count_pts_3d_sp <- rasterize(pts_ext_3d_sp, sa_clim_3d, fun = "count", field = "species") #make a raster out of the counts of observations per cell


#plot count map
leaflet(data = sa_clim_3d) %>% 
  addTiles() %>%
  addRasterImage(count_pts_3d_sp, colors = pal.species,  opacity = 0.8) %>%
  addLegend(pal = pal.species, values = values(count_pts_3d_sp))
```

###Genetic Diversity

Here, I'm extracting the nexus files for each species in each grid cell (i.e. the same species may have multiple nexus files if it's in multiple grid cells) and calculating pi from them.

Here's some housekeeping before applying to each spatial filtering level.
```{r}
library(ape) #for reading in and writing nexus files
library(gdata) #for drop.levels function so I can just drop levels from the whole dataframe
seq.files <- list.files("/Users/connorfrench/Dropbox/Old_Mac/School_Stuff/CUNY/BigAss-bird-phylogeography/S1_Data", pattern = ".nex")
all.seq <- list()
for (file in 1:length(seq.files)){ #making a master nexus file of all those from the supplemental data.
  #print(seq.files[file]) #print when first running on a data sets so you can tell which file is corrupt if an error occurs. Probably more reasonable to add an if/then statement, but whatever
  sp.nex <- read.nexus.data(paste("../S1_Data/", seq.files[file], sep = ""))
  all.seq <- append(all.seq, sp.nex)
}

#create function to calculate mean raw genetic distance (pi) from the sequences
pi.calc.fun <- function(x) {
  y <- read.nexus.data(x)
  z <- as.DNAbin(y)
  dist <- dist.dna(z, model = "raw")
  return(mean(dist))
}
```



100x100 km resolution. Values are mean pi per raster cell.
```{r}
#split data frame by cell number and species, creating nexus files for each species per cell
species.seq.split.one <- pts_ext_1d %>%
  as.data.frame() %>% #some functions don't like spatial data frames
  drop.levels() %>%
  split(.$cells) %>% #split into a list of data frames, grouped by cell. Splitting by both cells and species at once doesn't work.
  lapply(drop.levels) %>% #drop any levels in the data frame. Have to perform first because extra factor levels can mess up the split function
  lapply(function(x){
  split(x, x$Species)}) %>% #split each cell by species
  drop.levels()

#write a nexus file for each species per cell. Filtering all nexus files with less than 3 sequences for now- will update once the missing sequences are accounted for 
dir.create("../bird-seqs-one")
for (i in 1:length(species.seq.split.one)) {
  df <- species.seq.split.one[[i]]
  for (j in 1:length(df)){
    samples <- as.vector(df[[j]]$Sample.Name) #make a vector of sample names from each data set
    seqs <- all.seq[samples] #subset all.seq for the samples
    seqs2 <- Filter(Negate(is.null), seqs) #remove any null results (i.e. remove if a sample name from the spreadsheet doesn't match with a sample from the nexus)
    if(length(seqs2) < 3) next #don't write to a nexus file if there are less than 3 sequences
    write.nexus.data(seqs2, file = paste0("../bird-seqs-one/", names(species.seq.split.one)[[i]], ".", names(df)[[j]], ".nex"), interleaved = FALSE) #write to a nexus file, which is named by the cell number
  }
}



#get a list of the nexus files
files <- paste0("../bird-seqs-one/", list.files("../bird-seqs-one"))

pi.total.one <- files %>% sapply(pi.calc.fun) #calculate pi for all each species within each cell

pi.names.one <- str_match_all(names(pi.total.one), "[0-9]+") %>% unlist() #make a vector of the cell numbers for each pi calculation

pi.df.one <- bind_cols(cells = pi.names.one, pi = pi.total.one) #create dataframe of pi calculations

pi.means.one <- pi.df.one %>% group_by(cells) %>% dplyr::summarise(mean.pi = mean(pi), sd.pi = sd(pi)) #calculate pi for each cell number. I'm using dplyr::summarise because plyr also has a summarise function that can create a lot of confusion.

pts.ext.one.pi <- merge(pts_ext_1d, pi.means.one, by = "cells") #make new spatial data frame including the pi values

pi.raster.one <- rasterize(pts.ext.one.pi, sa_clim_1d, fun = "first", field = "mean.pi") #create new raster of mean pi values per cell

pal.one <- colorBin(palette = "inferno", domain =NULL, bins= c(0, .001, .002, .003, .004, .005, .01, .02, .03, .04, .05), na.color = "#00000000") 
leaflet() %>% 
  addTiles() %>%
  addRasterImage(pi.raster.one, colors = pal.one,  opacity = 0.8) %>%
  addLegend(pal = pal.one, values = values(pi.raster.one))


```



200x200 km
```{r}
#split data frame by cell number and species, creating nexus files for each species per cell
species.seq.split.two <- pts_ext_2d %>%
  as.data.frame() %>% #some functions don't like spatial data frames
  drop.levels() %>%
  split(.$cells) %>% #split into a list of data frames, grouped by cell. Splitting by both cells and species at once doesn't work.
  lapply(drop.levels) %>% #drop any levels in the data frame. Have to perform first because extra factor levels can mess up the split function
  lapply(function(x){
  split(x, x$Species)}) %>% #split each cell by species
  drop.levels()

#write a nexus file for each group of sequences from a cell. 
dir.create("../bird-seqs-two")
for (i in 1:length(species.seq.split.two)) {
  df <- species.seq.split.two[[i]]
  for (j in 1:length(df)){
    samples <- as.vector(df[[j]]$Sample.Name) #make a vector of sample names from each data set
    seqs <- all.seq[samples] #subset all.seq for the samples
    seqs2 <- Filter(Negate(is.null), seqs) #remove any null results (i.e. remove if a sample name from the spreadsheet doesn't match with a sample from the nexus)
    if(length(seqs2) < 3) next #don't write to a nexus file if there are less than 3 sequences
    write.nexus.data(seqs2, file = paste0("../bird-seqs-two/", names(species.seq.split.two)[[i]], ".", names(df)[[j]], ".nex"), interleaved = FALSE) #write to a nexus file, which is named by the cell number
  }
}



#get a list of the nexus files
files <- paste0("../bird-seqs-two/", list.files("../bird-seqs-two"))

pi.total.two <- files %>% sapply(pi.calc.fun) #calculate pi for all each species within each cell

pi.names.two <- str_match_all(names(pi.total.two), "[0-9]+") %>% unlist() #make a vector of the cell numbers for each pi calculation

pi.df.two <- bind_cols(cells = pi.names.two, pi = pi.total.two) #create dataframe of pi calculations

pi.means.two <- pi.df.two %>% group_by(cells) %>% dplyr::summarise(mean.pi = mean(pi), sd.pi = sd(pi)) #calculate pi for each cell number. I'm using dplyr::summarise because plyr also has a summarise function that can create a lot of confusion.

pts.ext.two.pi <- merge(pts_ext_2d, pi.means.two, by = "cells") #make new spatial data frame including the pi values

pi.raster.two <- rasterize(pts.ext.two.pi, sa_clim_2d, fun = "first", field = "mean.pi") #create new raster of mean pi values per cell

pal.two <- colorBin(palette = "inferno", domain =NULL, bins= c(0, .001, .002, .003, .004, .005, .01, .02, .03, .04, .05), na.color = "#00000000") 
leaflet() %>% 
  addTiles() %>%
  addRasterImage(pi.raster.two, colors = pal.two,  opacity = 0.8) %>%
  addLegend(pal = pal.two, values = values(pi.raster.two))


```


300x300 km
```{r}
#split data frame by cell number and species, creating nexus files for each species per cell
species.seq.split.three <- pts_ext_3d %>%
  as.data.frame() %>% #some functions don't like spatial data frames
  drop.levels() %>%
  split(.$cells) %>% #split into a list of data frames, grouped by cell. Splitting by both cells and species at once doesn't work.
  lapply(drop.levels) %>% #drop any levels in the data frame. Have to perform first because extra factor levels can mess up the split function
  lapply(function(x){
  split(x, x$Species)}) %>% #split each cell by species
  drop.levels()

#write a nexus file for each group of sequences from a cell. 
dir.create("../bird-seqs-three")
for (i in 1:length(species.seq.split.three)) {
  df <- species.seq.split.three[[i]]
  for (j in 1:length(df)){
    samples <- as.vector(df[[j]]$Sample.Name) #make a vector of sample names from each data set
    seqs <- all.seq[samples] #subset all.seq for the samples
    seqs2 <- Filter(Negate(is.null), seqs) #remove any null results (i.e. remove if a sample name from the spreadsheet doesn't match with a sample from the nexus)
    if(length(seqs2) < 3) next #don't write to a nexus file if there are less than 3 sequences
    write.nexus.data(seqs2, file = paste0("../bird-seqs-three/", names(species.seq.split.three)[[i]], ".", names(df)[[j]], ".nex"), interleaved = FALSE) #write to a nexus file, which is named by the cell number
  }
}



#get a list of the nexus files
files <- paste0("../bird-seqs-three/", list.files("../bird-seqs-three"))

pi.total.three <- files %>% sapply(pi.calc.fun) #calculate pi for all each species within each cell

pi.names.three <- str_match_all(names(pi.total.three), "[0-9]+") %>% unlist() #make a vector of the cell numbers for each pi calculation

pi.df.three <- bind_cols(cells = pi.names.three, pi = pi.total.three) #create dataframe of pi calculations

pi.means.three <- pi.df.three %>% group_by(cells) %>% dplyr::summarise(mean.pi = mean(pi), sd.pi = sd(pi)) #calculate pi for each cell number. I'm using dplyr::summarise because plyr also has a summarise function that can create a lot of confusion.

pts.ext.three.pi <- merge(pts_ext_3d, pi.means.three, by = "cells") #make new spatial data frame including the pi values

pi.raster.three <- rasterize(pts.ext.three.pi, sa_clim_3d, fun = "first", field = "mean.pi") #create new raster of mean pi values per cell

pal.three <- colorBin(palette = "inferno", domain =NULL, bins= c(0, .001, .002, .003, .004, .005, .01, .02, .03, .04, .05), na.color = "#00000000") 
leaflet() %>% 
  addTiles() %>%
  addRasterImage(pi.raster.three, colors = pal.three,  opacity = 0.8) %>%
  addLegend(pal = pal.three, values = values(pi.raster.three))
```


###Genetic Diversity Error
Here, I'm mapping the standard deviation of pi per cell. This does not take into account the within-species uncertainty (i.e. it calculates the standard deviation of mean pi values among species within the cell). In addition, I'm plotting a scatterplot of standard deviation and mean. I want to see if there are any error trends (e.g. higher mean pi = higher error). It looks like there is a positive association.

Just a note- there are fewer colored cells than the genetic diversity maps because taking the standard deviation of a single number returns an NA, which doesn't get plotted. Some cells 

100x100 km
```{r}
pi.raster.sd.one <- rasterize(pts.ext.one.pi, sa_clim_1d, fun = "first", field = "sd.pi") #create new raster of mean pi values per cell

leaflet() %>% 
  addTiles() %>%
  addRasterImage(pi.raster.sd.one, colors = pal.one,  opacity = 0.8) %>%
  addLegend(pal = pal.one, values = values(pi.raster.one))

plot(pts.ext.one.pi$mean.pi, pts.ext.one.pi$sd.pi)

```


200x200 km
```{r}
pi.raster.sd.two <- rasterize(pts.ext.two.pi, sa_clim_2d, fun = "first", field = "sd.pi") #create new raster of mean pi values per cell

leaflet() %>% 
  addTiles() %>%
  addRasterImage(pi.raster.sd.two, colors = pal.two,  opacity = 0.8) %>%
  addLegend(pal = pal.two, values = values(pi.raster.sd.two))

plot(pts.ext.two.pi$mean.pi, pts.ext.two.pi$sd.pi)
```

300x300 km
```{r}
pi.raster.sd.three <- rasterize(pts.ext.three.pi, sa_clim_3d, fun = "first", field = "sd.pi") #create new raster of mean pi values per cell

leaflet() %>% 
  addTiles() %>%
  addRasterImage(pi.raster.sd.three, colors = pal.three,  opacity = 0.8) %>%
  addLegend(pal = pal.three, values = values(pi.raster.sd.three))

plot(pts.ext.three.pi$mean.pi, pts.ext.three.pi$sd.pi)
```


###Accession Filter
I'm going to find and remove duplicate individuals from the datasets. Combined data set has 59948 observations. Removed 9681 individuals with the same accession number between datasets and remove 569 individuals without accession numbers
```{r}
miraldo.data <- read.csv("datasets/Miraldoetal_GPS-total.csv") %>%
  
  
  #I edited this spreadsheet to separate genus from species. This makes it different from the other Miraldo spreadsheets in case anyone is confused
names(miraldo.data)[6] = "accession"
names(miraldo.data)[3] = "latitude"
names(miraldo.data)[4] = "longitude"
pelletier.miraldo <- bind_rows(pelletier.vert, miraldo.data) %>%
  subset(!duplicated(accession))

coord.points.all <- st_as_sf(pelletier.miraldo, coords = c("longitude", "latitude"), 
                         crs = 4326, agr = "constant")

#create popup labels for points
#popup_label <- paste(coord_points$genus, coord_points$Species, "<br>",
#                     coord_points$Country, "<br>",
#                     coord_points$Locality, "<br>",
#                     coord_points$geometry)

#plot in leafly
leaflet() %>% 
  addTiles() %>%
  addCircleMarkers(data = coord.points.all,
                  #color = ~pal(Country),
                  radius = 5)

```



