---
title: "BigAss bird phylogeography data exploration"
output: html_notebook
---
Here are some maps exploring our bird data. I have two sets of maps: Maps only with cells where there are at least three individuals per species (>= 3 species tab), and maps that show the species density, rather than observation density (Species density tab). 

First I'm reading in the packages and reading in the data.
```{r, results='hide'}
packages <- c("magrittr", "tidyverse", "sf", "leaflet", "maps", "ggmap", "viridis", "raster", "maptools", "data.table")
lapply(packages, require, character.only = TRUE)


#read in data
bird_data <- read.csv("datasets/sample_key_68_clean.csv")
```


I'm removing all of the irrelevant columns for mapping, I'm only keeping ingroup individuals, and I'm removing all localities that aren't in South America.

```{r}
#remove irrelevant columns, NAs, North American/European localities,and subset for ingroup individuals. orig # obs = 18954; filtered # obs = 2825
bird_data <- subset(bird_data, select = c("Sample.Name","Country", "State", "Locality", "Genus", "Species", "Ingroup", "Lat", "Long")) %>%
  subset(Ingroup == "y") %>%
  subset(Lat < 12.5) %>%
  subset(!(Country %in% c("Mexico", "Cuba", "Bahamas", "Dominican Republic", "Nicaragua", "Costa Rica", "Panama"))) %>% 
  na.omit() %>%
  drop.levels()


```

The original number of observations was 18954, and the filtered number of observations is 2825.

Now time for the map! This is of all of our South American localities colored according to country to find outlier/mislabeled points.

```{r}
#convert locality data to a spatial object. The spatial object is basically a shape file that the mapping function can interpret. 
coord_points <- st_as_sf(bird_data, coords = c("Long", "Lat"), 
                         crs = 4326, agr = "constant")


#load a world map as the base map.
w_map <- map("world", plot = FALSE)

#make color palette
pal <- colorFactor(palette = "inferno", domain = NULL, na.color = "#00000000")

#create popup labels for points
popup_label <- paste(coord_points$Genus, coord_points$Species, "<br>",
                     coord_points$Country, "<br>",
                     coord_points$Locality, "<br>",
                     coord_points$geometry)

#plot in leafly
leaflet(data = w_map) %>% 
  addTiles() %>%
  addCircleMarkers(data = coord_points,
                  color = ~pal(Country),
                  radius = 5,
                  popup = popup_label)
```


Now I'm going to apply various filters to the data to look at sampling intensity.

##Sampling Maps {.tabset}


###>=3 per species
Here I'm subsetting the data for only those cells where there are more than 3 observations for a species and then plotting.

100x100 km. Dataset is reduced from 68 to 49 species and from 2825 observations to 1700 observations.
```{r}
#create a numeric color palette so I can bin the colors (doing this up front so I don't repeatedly assign this variable)
pal.numseq <- colorBin(palette = "inferno", domain = NULL, bins = c(1,3,5,7,10,20,40,60,80), na.color = "#00000000")
#Reading in an environmental raster (world clim 2.0 bio1 raster) at 10 arc-minute resolution to use as a raster that utilizes lat-long coordinates for its cells. The raster isn't what's important, what is important is the raster resolution. 
f <- "/Users/connorfrench/Dropbox/Old_Mac/climate-data/wc2.0_10m_bio/wc2.0_bio_10m_01.tif" #raster location

bounds <- extent(-80, -35, -40, 15) #Reduce extent of raster to our area of interest- South America

sa_clim_1d <- raster(f) %>% crop(bounds) %>% aggregate(fact = 6) #read in raster, crop it, and downscale the resolution to 1 degree

#get the cell number of each coordinate pair for filtering
pts_ext_1d <- raster::extract(sa_clim_1d, coord_points, fun = "count", sp = TRUE, cellnumbers = TRUE) %>% 
  as.data.frame() %>%
  setnames(old = c("coords.x1", "coords.x2"), new = c("Long", "Lat")) %>% #rename coordinates 
  mutate(cells = as.factor(cells)) %>% #need cells numbers as factors so I can count their frequency
  group_by(Species, cells) %>% #group the data set by species, then by cell number
  filter(n() > 2) %>% #retain only observations where there are more than two species observations per cell
  ungroup() %>%
  drop.levels()

coordinates(pts_ext_1d) <- ~Long+Lat #convert to a spatial data frame

count_pts_1d <- rasterize(pts_ext_1d, sa_clim_1d, fun = "count", field = "Species") #make a raster out of the counts of observations per cell


#plot count map
leaflet(data = sa_clim_1d) %>% 
  addTiles() %>%
  addRasterImage(count_pts_1d, colors = pal.numseq,  opacity = 0.8) %>%
  addLegend(pal = pal.numseq, values = values(count_pts_1d))
```




200x200 km. 68 to 49 species and 2825 to 1955 observations

```{r}
sa_clim_2d <- raster(f) %>% crop(bounds) %>% aggregate(fact = 12) #read in raster, crop it, and downscale the resolution to 1 degree

#get the cell number of each coordinate pair for filtering
pts_ext_2d <- raster::extract(sa_clim_2d, coord_points, fun = "count", sp = TRUE, cellnumbers = TRUE) %>% 
  as.data.frame() %>%
  setnames(old = c("coords.x1", "coords.x2"), new = c("Long", "Lat")) %>% #rename coordinates 
  mutate(cells = as.factor(cells)) %>% #need cells numbers as factors so I can count their frequency
  group_by(Species, cells) %>% #group the data set by species, then by cell number
  filter(n() > 2) %>% #retain only observations where there are more than two species observations per cell
  ungroup()

coordinates(pts_ext_2d) <- ~Long+Lat #convert to a spatial data frame

count_pts_2d <- rasterize(pts_ext_2d, sa_clim_2d, fun = "count", field = "Species") #make a raster out of the counts of observations per cell

pal.numseq.two <- colorBin(palette = "inferno", domain = NULL, bins = c(1,3,5,7,10,20,40,60,80,120,160), na.color = "#00000000")

#plot count map
leaflet(data = sa_clim_2d) %>% 
  addTiles() %>%
  addRasterImage(count_pts_2d, colors = pal.numseq.two,  opacity = 0.8) %>%
  addLegend(pal = pal.numseq.two, values = values(count_pts_2d))
```


300x300 km. 68 to 54 species and 2825 to 2149 observations

```{r}
sa_clim_3d <- raster(f) %>% crop(bounds) %>% aggregate(fact = 18) #read in raster, crop it, and downscale the resolution to 1 degree

#get the cell number of each coordinate pair for filtering
pts_ext_3d <- raster::extract(sa_clim_3d, coord_points, fun = "count", sp = TRUE, cellnumbers = TRUE) %>% 
  as.data.frame() %>%
  setnames(old = c("coords.x1", "coords.x2"), new = c("Long", "Lat")) %>% #rename coordinates 
  mutate(cells = as.factor(cells)) %>% #need cells numbers as factors so I can count their frequency
  group_by(Species, cells) %>% #group the data set by species, then by cell number
  filter(n() > 2) %>% #retain only observations where there are more than two species observations per cell
  ungroup()

coordinates(pts_ext_3d) <- ~Long+Lat #convert to a spatial data frame

count_pts_3d <- rasterize(pts_ext_3d, sa_clim_3d, fun = "count", field = "Species") #make a raster out of the counts of observations per cell

pal.numseq.three <- colorBin(palette = "inferno", domain = NULL, bins = c(1,3,5,7,10,20,40,60,80,120,160), na.color = "#00000000")

#plot count map
leaflet(data = sa_clim_3d) %>% 
  addTiles() %>%
  addRasterImage(count_pts_3d, colors = pal.numseq.three,  opacity = 0.8) %>%
  addLegend(pal = pal.numseq.three, values = values(count_pts_3d))
```


###Species density
Now I'm going to look at species density per cell for the three resolutions! Just to be clear, this is still using the data set filtered for >= 3 observations per species per cell.

100 km. 
```{r}
pts_ext_1d_sp <- as.data.frame(pts_ext_1d) #convert to data frame for filtering
pts_ext_1d_sp <- pts_ext_1d_sp[!duplicated(pts_ext_1d_sp[c("Species", "cells")]),] #filter for unique species in each cell

coordinates(pts_ext_1d_sp) <- ~Long+Lat #convert to a spatial data frame

count_pts_1d_sp <- rasterize(pts_ext_1d_sp, sa_clim_1d, fun = "count", field = "Species") #make a raster out of the counts of observations per cell


#plot count map
leaflet(data = sa_clim_1d) %>% 
  addTiles() %>%
  addRasterImage(count_pts_1d_sp, colors = pal2,  opacity = 0.8) %>%
  addLegend(pal = pal2, values = values(count_pts_1d_sp))


```

200 km.
```{r}
pts_ext_2d_sp <- as.data.frame(pts_ext_2d) #convert to data frame for filtering
pts_ext_2d_sp <- pts_ext_2d_sp[!duplicated(pts_ext_2d_sp[c("Species", "cells")]),] #filter for unique species in each cell

coordinates(pts_ext_2d_sp) <- ~Long+Lat #convert to a spatial data frame

count_pts_2d_sp <- rasterize(pts_ext_2d_sp, sa_clim_2d, fun = "count", field = "Species") #make a raster out of the counts of observations per cell


#plot count map
leaflet(data = sa_clim_2d) %>% 
  addTiles() %>%
  addRasterImage(count_pts_2d_sp, colors = pal2,  opacity = 0.8) %>%
  addLegend(pal = pal2, values = values(count_pts_2d_sp))
```


300 km.
```{r}
pts_ext_3d_sp <- as.data.frame(pts_ext_3d) #convert to data frame for filtering
pts_ext_3d_sp <- pts_ext_3d_sp[!duplicated(pts_ext_3d_sp[c("Species", "cells")]),] #filter for unique species in each cell

coordinates(pts_ext_3d_sp) <- ~Long+Lat #convert to a spatial data frame

count_pts_3d_sp <- rasterize(pts_ext_3d_sp, sa_clim_3d, fun = "count", field = "Species") #make a raster out of the counts of observations per cell


#plot count map
leaflet(data = sa_clim_3d) %>% 
  addTiles() %>%
  addRasterImage(count_pts_3d_sp, colors = pal2,  opacity = 0.8) %>%
  addLegend(pal = pal2, values = values(count_pts_3d_sp))
```

###Genetic Diversity

Here, I'm extracting the nexus files for each species in each grid cell (i.e. the same species may have multiple nexus files if it's in multiple grid cells) and calculating pi from them.

Here's some housekeeping before applying to each spatial filtering level.
```{r}
library(ape) #for reading in and writing nexus files
library(gdata) #for drop.levels function so I can just drop levels from the whole dataframe
library(stringr) #to manipulate text for the names of the pi values output from my pi calculation function
seq.files <- list.files("/Users/connorfrench/Dropbox/Old_Mac/School_Stuff/CUNY/BigAss-bird-phylogeography/S1_Data", pattern = ".nex") #create a list of sequence files

#for loop to read in nexus files
all.seq <- list() 
for (file in 1:length(seq.files)){
  #print(seq.files[file]) #print when first running on a data sets so you can tell which file is corrupt if an error occurs. Probably more reasonable to add an if/then statement, but whatever
  sp.nex <- read.nexus.data(paste("../S1_Data/", seq.files[file], sep = ""))
  all.seq <- append(all.seq, sp.nex)
}

#create function to calculate mean raw genetic distance (pi) from the sequences
pi.calc.fun <- function(x) {
  y <- read.nexus.data(x)
  z <- as.DNAbin(y)
  dist <- dist.dna(z, model = "raw")
  return(mean(dist))
}

#count the number of sequences per species per cell
num.seq.fun <- function(x) {
  y <- read.nexus.data(x)
  z <- as.DNAbin(y)
  num <- length(z)
  return(num)
}
```



100x100 km resolution. Values are mean pi per raster cell.
```{r}
#split data frame by cell number and species, creating nexus files for each species per cell
species.seq.split.one <- pts_ext_1d %>%
  as.data.frame() %>% #some functions don't like spatial data frames
  drop.levels() %>%
  split(.$cells) %>% #split into a list of data frames, grouped by cell. Splitting by both cells and species at once doesn't work.
  lapply(drop.levels) %>% #drop any levels in the data frame. Have to perform first because extra factor levels can mess up the split function
  lapply(function(x){
  split(x, x$Species)}) %>% #split each cell by species
  drop.levels()

#write a nexus file for each group of sequences from a cell. 
dir.create("../bird-seqs-one")
for (i in 1:length(species.seq.split.one)) {
  df <- species.seq.split.one[[i]]
  for (j in 1:length(df)){
    samples <- df[[j]]$Sample.Name#make a vector of sample names from each data set
    seqs <- all.seq[samples] #subset all.seq for the samples
    #seqs2 <- Filter(Negate(is.null), seqs) #remove any null results (i.e. remove if a sample name from the spreadsheet doesn't match with a sample from the nexus)
    if(length(seqs) < 3) next #don't write to a nexus file if there are less than 3 sequences
    write.nexus.data(seqs, file = paste0("../bird-seqs-one/", names(species.seq.split.one)[[i]], ".", names(df)[[j]], ".nex"), interleaved = FALSE) #write to a nexus file, which is named by the cell number
  }
}



#get a list of the nexus files
files <- paste0("../bird-seqs-one/", list.files("../bird-seqs-one"))

pi.total.one <- files %>% sapply(pi.calc.fun) #calculate pi for all each species within each cell
num.seq.one <- files %>% sapply(num.seq.fun)

pi.names.one <- str_match_all(names(pi.total.one), "[0-9]+") %>% unlist() #make a vector of the cell numbers for each pi calculation

pi.df.one <- bind_cols(cells = pi.names.one, pi = unname(pi.total.one), numseq = unname(num.seq.one)) #create dataframe of pi calculations

pi.means.one <- pi.df.one %>% group_by(cells) %>% dplyr::summarise(mean.pi = mean(pi), sd.pi = sd(pi), numseq = sum(numseq)) #calculate pi for each cell number. I'm using dplyr::summarise because plyr also has a summarise function that can create a lot of confusion.

pts.ext.one.pi <- merge(pts_ext_1d, pi.means.one, by = "cells") #make new spatial data frame including the pi values

pi.raster.one <- rasterize(pts.ext.one.pi, sa_clim_1d, fun = "first", field = "mean.pi") #create new raster of mean pi values per cell


leaflet() %>% 
  addTiles() %>%
  addRasterImage(pi.raster.one, colors = pal.one,  opacity = 0.8) %>%
  addLegend(pal = pal.one, values = values(pi.raster.one))

#plot the mean pi value as a function of the number of sequences to see if the number of sequences influence the calculation of genetic diversity. It appears to.
plot(pi.means.one$mean.pi ~ pi.means.one$numseq)
model <- lm(mean.pi ~ numseq, data = pi.means.one)
abline(model)
```



200x200 km
```{r}
#split data frame by cell number and species, creating nexus files for each species per cell
species.seq.split.two <- pts_ext_2d %>%
  as.data.frame() %>% #some functions don't like spatial data frames
  drop.levels() %>%
  split(.$cells) %>% #split into a list of data frames, grouped by cell. Splitting by both cells and species at once doesn't work.
  lapply(drop.levels) %>% #drop any levels in the data frame. Have to perform first because extra factor levels can mess up the split function
  lapply(function(x){
  split(x, x$Species)}) %>% #split each cell by species
  drop.levels()

#write a nexus file for each group of sequences from a cell. 
dir.create("../bird-seqs-two")
for (i in 1:length(species.seq.split.two)) {
  df <- species.seq.split.two[[i]]
  for (j in 1:length(df)){
    samples <- df[[j]]$Sample.Name #make a vector of sample names from each data set
    seqs <- all.seq[samples] #subset all.seq for the samples
    #seqs2 <- Filter(Negate(is.null), seqs) #remove any null results (i.e. remove if a sample name from the spreadsheet doesn't match with a sample from the nexus)
    if(length(seqs) < 3) next #don't write to a nexus file if there are less than 3 sequences
    write.nexus.data(seqs, file = paste0("../bird-seqs-two/", names(species.seq.split.two)[[i]], ".", names(df)[[j]], ".nex"), interleaved = FALSE) #write to a nexus file, which is named by the cell number
  }
}



#get a list of the nexus files
files <- paste0("../bird-seqs-two/", list.files("../bird-seqs-two"))

pi.total.two <- files %>% sapply(pi.calc.fun) #calculate pi for all each species within each cell
num.seq.two <- files %>% sapply(num.seq.fun)

pi.names.two <- str_match_all(names(pi.total.two), "[0-9]+") %>% unlist() #make a vector of the cell numbers for each pi calculation

pi.df.two <- bind_cols(cells = pi.names.two, pi = unname(pi.total.two), numseq = unname(num.seq.two)) #create dataframe of pi calculations

pi.means.two <- pi.df.two %>% group_by(cells) %>% dplyr::summarise(mean.pi = mean(pi), sd.pi = sd(pi), numseq = sum(numseq)) #calculate pi for each cell number. I'm using dplyr::summarise because plyr also has a summarise function that can create a lot of confusion.

pts.ext.two.pi <- merge(pts_ext_2d, pi.means.two, by = "cells") #make new spatial data frame including the pi values

pi.raster.two <- rasterize(pts.ext.two.pi, sa_clim_2d, fun = "first", field = "mean.pi") #create new raster of mean pi values per cell


leaflet() %>% 
  addTiles() %>%
  addRasterImage(pi.raster.two, colors = pal.one,  opacity = 0.8) %>%
  addLegend(pal = pal.one, values = values(pi.raster.two))

plot(pi.means.two$mean.pi ~ pi.means.two$numseq)
model <- lm(mean.pi ~ numseq, data = pi.means.two)
abline(model)
```


300x300 km
```{r}
#split data frame by cell number and species, creating nexus files for each species per cell
species.seq.split.three <- pts_ext_3d %>%
  as.data.frame() %>% #some functions don't like spatial data frames
  drop.levels() %>%
  split(.$cells) %>% #split into a list of data frames, grouped by cell. Splitting by both cells and species at once doesn't work.
  lapply(drop.levels) %>% #drop any levels in the data frame. Have to perform first because extra factor levels can mess up the split function
  lapply(function(x){
  split(x, x$Species)}) %>% #split each cell by species
  drop.levels()

#write a nexus file for each group of sequences from a cell. 
dir.create("../bird-seqs-three")
for (i in 1:length(species.seq.split.three)) {
  df <- species.seq.split.three[[i]]
  for (j in 1:length(df)){
    samples <- df[[j]]$Sample.Name #make a vector of sample names from each data set
    seqs <- all.seq[samples] #subset all.seq for the samples
    #seqs2 <- Filter(Negate(is.null), seqs) #remove any null results (i.e. remove if a sample name from the spreadsheet doesn't match with a sample from the nexus)
    if(length(seqs) < 3) next #don't write to a nexus file if there are less than 3 sequences
    write.nexus.data(seqs, file = paste0("../bird-seqs-three/", names(species.seq.split.three)[[i]], ".", names(df)[[j]], ".nex"), interleaved = FALSE) #write to a nexus file, which is named by the cell number
  }
}



#get a list of the nexus files
files <- paste0("../bird-seqs-three/", list.files("../bird-seqs-three"))

pi.total.three <- files %>% sapply(pi.calc.fun) #calculate pi for all each species within each cell
num.seq.three <- files %>% sapply(num.seq.fun)

pi.names.three <- str_match_all(names(pi.total.three), "[0-9]+") %>% unlist() #make a vector of the cell numbers for each pi calculation

pi.df.three <- bind_cols(cells = pi.names.three, pi = unname(pi.total.three), numseq = unname(num.seq.three)) #create dataframe of pi calculations

pi.means.three <- pi.df.three %>% group_by(cells) %>% dplyr::summarise(mean.pi = mean(pi), sd.pi = sd(pi), numseq = sum(numseq)) #calculate pi for each cell number. I'm using dplyr::summarise because plyr also has a summarise function that can create a lot of confusion.

pts.ext.three.pi <- merge(pts_ext_3d, pi.means.three, by = "cells") #make new spatial data frame including the pi values

pi.raster.three <- rasterize(pts.ext.three.pi, sa_clim_3d, fun = "first", field = "mean.pi") #create new raster of mean pi values per cell


leaflet() %>% 
  addTiles() %>%
  addRasterImage(pi.raster.three, colors = pal.one,  opacity = 0.8) %>%
  addLegend(pal = pal.one, values = values(pi.raster.three))

#plot the mean pi value as a function of the number of sequences to see if the number of sequences influence the calculation of genetic diversity. It appears to.
plot(pi.means.three$mean.pi ~ pi.means.three$numseq)
model <- lm(mean.pi ~ numseq, data = pi.means.three)
abline(model)

```


###Genetic Diversity Error
Here, I'm mapping the standard deviation of pi per cell. This does not take into account the within-species uncertainty (i.e. it calculates the standard deviation of mean pi values among species within the cell). In addition, I'm plotting a scatterplot of standard deviation and mean. I want to see if there are any error trends (e.g. higher mean pi = higher error). It looks like there is a positive association.

Just a note- there are fewer colored cells than the genetic diversity maps because taking the standard deviation of a single number returns an NA, which doesn't get plotted. Some cells 

100x100 km
```{r}
pi.raster.sd.one <- rasterize(pts.ext.one.pi, sa_clim_1d, fun = "first", field = "sd.pi") #create new raster of mean pi values per cell

leaflet() %>% 
  addTiles() %>%
  addRasterImage(pi.raster.sd.one, colors = pal.one,  opacity = 0.8) %>%
  addLegend(pal = pal.one, values = values(pi.raster.sd.one))

#plot the mean pi value as a function of the number of sequences to see if the number of sequences influence the calculation of genetic diversity. It appears to.
plot(pi.means.one$sd.pi ~ pi.means.one$numseq)
model <- lm(sd.pi ~ numseq, data = pi.means.one)
abline(model)
```


200x200 km
```{r}
pi.raster.sd.two <- rasterize(pts.ext.two.pi, sa_clim_2d, fun = "first", field = "sd.pi") #create new raster of mean pi values per cell

leaflet() %>% 
  addTiles() %>%
  addRasterImage(pi.raster.sd.two, colors = pal.one,  opacity = 0.8) %>%
  addLegend(pal = pal.one, values = values(pi.raster.sd.two))

#plot the mean pi value as a function of the number of sequences to see if the number of sequences influence the calculation of genetic diversity. It appears to.
plot(pi.means.two$sd.pi ~ pi.means.two$numseq)
model <- lm(sd.pi ~ numseq, data = pi.means.two)
abline(model)
```

300x300 km
```{r}
pi.raster.sd.three <- rasterize(pts.ext.three.pi, sa_clim_3d, fun = "first", field = "sd.pi") #create new raster of mean pi values per cell

leaflet() %>% 
  addTiles() %>%
  addRasterImage(pi.raster.sd.three, colors = pal.one,  opacity = 0.8) %>%
  addLegend(pal = pal.one, values = values(pi.raster.sd.three))

#plot the mean pi value as a function of the number of sequences to see if the number of sequences influence the calculation of genetic diversity. It appears to.
plot(pi.means.three$sd.pi ~ pi.means.three$numseq)
model <- lm(sd.pi ~ numseq, data = pi.means.three)
abline(model)
```


###Num Sequences
This is just a sanity check to make sure there weren't any major differences in the number of sequences extracted and the number of sequences listed in the spreadsheet. These should look similar to the plots in the ">3 per species" tab.

100 x 100 km
```{r}
pi.raster.numseq.one <- rasterize(pts.ext.one.pi, sa_clim_1d, fun = "first", field = "numseq") #create new raster of mean pi values per cell

pal.numseq <- colorBin(palette = "inferno", domain = NULL, bins = c(1,3,5,7,10,20,40,60,80), na.color = "#00000000")

leaflet() %>% 
  addTiles() %>%
  addRasterImage(pi.raster.numseq.one, colors = pal.numseq,  opacity = 0.8) %>%
  addLegend(pal = pal.numseq, values = values(pi.raster.numseq.one))
```


200 x 200 km
```{r}
pi.raster.numseq.two <- rasterize(pts.ext.two.pi, sa_clim_2d, fun = "first", field = "numseq") #create new raster of mean pi values per cell

pal.numseq.two <- colorBin(palette = "inferno", domain = NULL, bins = c(1,3,5,7,10,20,40,60,80,120,160), na.color = "#00000000")

leaflet() %>% 
  addTiles() %>%
  addRasterImage(pi.raster.numseq.two, colors = pal.numseq.two,  opacity = 0.8) %>%
  addLegend(pal = pal.numseq.two, values = values(pi.raster.numseq.two))
```


300 x 300 km
```{r}
pi.raster.numseq.three <- rasterize(pts.ext.three.pi, sa_clim_3d, fun = "first", field = "numseq") #create new raster of mean pi values per cell

pal.numseq.three <- colorBin(palette = "inferno", domain = NULL, bins = c(1,3,5,7,10,20,40,60,80,120,160), na.color = "#00000000")

leaflet() %>% 
  addTiles() %>%
  addRasterImage(pi.raster.numseq.three, colors = pal.numseq.three,  opacity = 0.8) %>%
  addLegend(pal = pal.numseq.three, values = values(pi.raster.numseq.three))

```

###Accession Filter
I'm going to find and remove duplicate individuals from the datasets
```{r}
miraldo.data <- read.csv("")
```


